{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Euler Graph Database","text":""},{"location":"#introduction-to-euler-graph-database","title":"Introduction to Euler Graph Database","text":"<p>The Euler Graph Database is a knowledge graph viewer that allows users to create, visualize, and manage knowledge graphs. It provides an interactive graphical user interface (GUI) for performing various operations on the knowledge graph such as adding nodes and edges, executing queries, and visualizing the graph. Additionally, it includes features like embedding, path finding, and tokenization that help you build a complete Graph-based Retrieval Augmented Generation (GraphRAG) system. You can also visualize the graphs directly from your terminal by typing <code>eulerdb</code>.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Interactive GUI: A user-friendly interface for managing knowledge graphs.</li> <li>Node and Edge Management: Easily add, edit, and delete nodes and edges in your graph.</li> <li>Query Execution: Perform complex queries to retrieve and analyze graph data.</li> <li>Graph Visualization: Visualize your knowledge graphs to better understand the relationships and structure.</li> <li>Embedding: Generate embeddings for nodes to facilitate advanced graph-based analysis.</li> <li>Path Finding: Implement algorithms to find paths between nodes.</li> <li>Tokenization: Tokenize graph data for various processing tasks.</li> <li>GraphRAG: Build and utilize Graph-based Retrieval Augmented Generation systems.</li> </ul>"},{"location":"#building-knowledge-graphs","title":"Building Knowledge Graphs \ud83c\udf10","text":"<p>Using the provided classes, you can build comprehensive knowledge graphs. These graphs can help in organizing information, discovering relationships, and enhancing data analysis.</p>"},{"location":"#benefits","title":"Benefits:","text":"<ul> <li>Organized Data: Represent your data in an easily understandable graph format.</li> <li>Relationship Discovery: Identify and explore relationships between different data points.</li> <li>Enhanced Analysis: Use graph-based analysis techniques to gain deeper insights into your data.</li> </ul>"},{"location":"#graphrag-graph-based-retrieval-augmented-generation","title":"GraphRAG (Graph-based Retrieval Augmented Generation) \ud83d\ude80","text":"<p>GraphRAG is a powerful technique that leverages knowledge graphs to enhance information retrieval and generation processes. By building and utilizing knowledge graphs, GraphRAG can provide more accurate and contextually relevant information.</p>"},{"location":"#benefits_1","title":"Benefits:","text":"<ul> <li>Improved Retrieval: Enhance search and retrieval processes by leveraging the structure and relationships in knowledge graphs.</li> <li>Contextual Generation: Generate contextually relevant information based on the interconnected data within the graph.</li> <li>Advanced Insights: Use the power of knowledge graphs to derive insights that are not possible with traditional retrieval methods.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<p>To install Euler Graph Database, you can use the following commands:</p> <pre><code>pip install eulerdb\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>To get started with the Euler Graph Database, follow these steps:</p> <pre><code>from my_graph_lib.graph_api import KnowledgeGraphAPI\nfrom my_graph_lib.faiss_db import FaissVectorDB\n\n# Initialize API and Vector DB\napi = KnowledgeGraphAPI()\nvector_db = FaissVectorDB(dimension=64)\n</code></pre>"},{"location":"#create-nodes","title":"Create nodes","text":"<p>Create Graph nodes </p> <pre><code>api.create_node(id='1', label='Person', properties={'name': 'Alice', 'age': 30})\napi.create_node(id='2', label='Person', properties={'name': 'Bob', 'age': 35})\napi.create_node(id='3', label='Person', properties={'name': 'Charlie', 'age': 25})\napi.create_node(id='4', label='Person', properties={'name': 'David', 'age': 40})\napi.create_node(id='5', label='Person', properties={'name': 'Eve', 'age': 28})\n</code></pre>"},{"location":"#create-edges","title":"Create edges","text":"<p>Create Graph Edges</p> <pre><code>api.create_edge(id='1-2', source='1', target='2', label='knows', properties={'since': '2020'})\napi.create_edge(id='2-3', source='2', target='3', label='knows', properties={'since': '2018'})\napi.create_edge(id='3-4', source='3', target='4', label='knows', properties={'since': '2015'})\napi.create_edge(id='4-5', source='4', target='5', label='knows', properties={'since': '2021'})\napi.create_edge(id='5-1', source='5', target='1', label='knows', properties={'since': '2019'})\n</code></pre>"},{"location":"#generate-embeddings","title":"Generate embeddings","text":"<p>Apply Embeddding on graphs</p> <pre><code>api.graph.generate_embeddings(method=\"simple\", dimensions=64)\nembeddings = {node_id: api.graph.get_embedding(node_id) for node_id in api.graph.nodes}\nvector_db.add_vectors(list(embeddings.values()), list(map(int, embeddings.keys())))\n</code></pre>"},{"location":"#query-embeddings","title":"Query embeddings","text":"<pre><code>query_results = vector_db.query_vectors(api.graph.get_embedding('1'), k=2)\nprint(\"Query results:\", query_results)\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p><code>docs/installation.md</code>:</p>"},{"location":"installation/#introduction-i","title":"Introduction \u2139\ufe0f","text":"<p>The Euler Graph Database is a knowledge graph viewer that allows users to create, visualize, and manage knowledge graphs. It provides an interactive graphical user interface (GUI) for performing various operations on the knowledge graph such as adding nodes and edges, executing queries, and visualizing the graph.</p>"},{"location":"installation/#installation","title":"Installation \ud83d\udcbb","text":"<ol> <li>Install the Package: <pre><code>    pip install euler_database\n</code></pre></li> </ol>"},{"location":"installation/#running-the-application","title":"Running the Application \ud83d\ude80","text":"<p>To run the application, use the following command: <pre><code>eulerdb\n</code></pre></p>"},{"location":"installation/#user-guide","title":"User Guide \ud83d\udcdd","text":""},{"location":"installation/#main-interface","title":"Main Interface \ud83d\udda5\ufe0f","text":"<p>The main interface of the application consists of the following components: - Header: Displays the application name and logo. - Navbar: Provides options to load, visualize, add nodes, add edges, save the graph, and display help/about information. - Query Entry: A text area to enter queries. - Buttons:      - <code>Execute Query</code>: Executes the entered query.     - <code>Save Query</code>: Saves the entered queries to a file.     - <code>Load Query</code>: Loads queries from a file. - Output Areas:     - <code>Query Output</code>: Displays the results of executed queries.     - <code>JSON Output</code>: Displays the JSON representation of the current graph.</p>"},{"location":"installation/#loading-a-graph","title":"Loading a Graph \ud83d\udcc2","text":"<ol> <li>Click on the <code>Load Graph</code> button in the navbar.</li> <li>Select the file containing the graph you want to load.</li> </ol>"},{"location":"installation/#visualizing-a-graph","title":"Visualizing a Graph \ud83d\udd0d","text":"<ol> <li>After loading a graph, click on the <code>Visualize Graph</code> button in the navbar.</li> <li>The graph will be displayed in the visualization area.</li> </ol>"},{"location":"installation/#adding-nodes","title":"Adding Nodes \u2795","text":"<ol> <li>Click on the <code>Add Node</code> button in the navbar.</li> <li>Enter the node ID and label in the prompt that appears.</li> <li>The node will be added to the graph.</li> </ol>"},{"location":"installation/#adding-edges","title":"Adding Edges \ud83d\udd17","text":"<ol> <li>Click on the <code>Add Edge</code> button in the navbar.</li> <li>Enter the edge ID, source node ID, target node ID, and edge label in the prompt that appears.</li> <li>The edge will be added to the graph.</li> </ol>"},{"location":"installation/#saving-a-graph","title":"Saving a Graph \ud83d\udcbe","text":"<ol> <li>Click on the <code>Save Graph</code> button in the navbar.</li> <li>Choose the location to save the graph file.</li> </ol>"},{"location":"installation/#executing-queries","title":"Executing Queries \ud83d\udccb","text":"<ol> <li>Enter your query in the <code>Query Entry</code> area.</li> <li>Click the <code>Execute Query</code> button.</li> <li>The result of the query will be displayed in the <code>Query Output</code> area.</li> </ol>"},{"location":"installation/#saving-queries","title":"Saving Queries \ud83d\udcbc","text":"<ol> <li>Enter your queries in the <code>Query Entry</code> area.</li> <li>Click the <code>Save Query</code> button.</li> <li>Choose the location to save the queries file (with <code>.euler</code> extension).</li> </ol>"},{"location":"installation/#loading-queries","title":"Loading Queries \ud83d\udcc4","text":"<ol> <li>Click the <code>Load Query</code> button.</li> <li>Select the file containing the queries.</li> <li>The queries will be loaded into the <code>Query Entry</code> area.</li> </ol>"},{"location":"installation/#example","title":"Example:","text":"<pre><code>from euler.graph_api import KnowledgeGraphAPI\nfrom euler.query_parser import QueryParser\nfrom euler.query_executor import QueryExecutor\n\n# Initialize API and related components\napi = KnowledgeGraphAPI()\nparser = QueryParser(api.graph)\nexecutor = QueryExecutor(api.graph)\n\n# Add nodes and edges\napi.create_node('1', 'Person', {'name': 'Alice'})\napi.create_node('2', 'Person', {'name': 'Bob'})\napi.create_edge('1', '1', '2', 'knows')\n\n# Query the graph\nresult = executor.execute_query('FIND (n)-[r]-&gt;(m)')\nprint(result)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p><code>usage.md</code>:</p> <p>```markdown</p>"},{"location":"usage/#usage","title":"Usage","text":"<p>This section provides examples of how to use My Graph Library.</p>"},{"location":"usage/#quick-start","title":"Quick Start","text":"<p>```python from my_graph_lib.graph_api import KnowledgeGraphAPI from my_graph_lib.faiss_db import FaissVectorDB</p> <p>api = KnowledgeGraphAPI() vector_db = FaissVectorDB(dimension=64)</p> <p>api.create_node(id='1', label='Person', properties={'name': 'Alice', 'age': 30})</p>"},{"location":"usage/#add-more-nodes-and-edges","title":"Add more nodes and edges...","text":"<p>api.graph.generate_embeddings(method=\"simple\", dimensions=64) embeddings = {node_id: api.graph.get_embedding(node_id) for node_id in api.graph.nodes} vector_db.add_vectors(list(embeddings.values()), list(map(int, embeddings.keys())))</p> <p>query_results = vector_db.query_vectors(api.graph.get_embedding('1'), k=2) print(\"Query results:\", query_results)</p>"},{"location":"api_reference/chunk/gn_cluster/","title":"GirvanNewmanClustering","text":""},{"location":"api_reference/chunk/gn_cluster/#overview","title":"Overview","text":"<p>The <code>GirvanNewmanClustering</code> class is designed to detect communities in a graph using the Girvan-Newman algorithm. It extends the <code>GraphClustering</code> class.</p>"},{"location":"api_reference/chunk/gn_cluster/#arguments","title":"Arguments","text":"<ul> <li><code>text</code> (str): The input text containing sentences to be clustered.</li> <li><code>resolution</code> (float): The resolution parameter for the Girvan-Newman algorithm.</li> <li><code>threshold</code> (float): The similarity threshold for connecting nodes in the graph.</li> </ul>"},{"location":"api_reference/chunk/gn_cluster/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>GirvanNewmanClustering</code> class:</p> <pre><code>from euler.clustering import GirvanNewmanClustering\n\ntext = \"\"\"\nYour text data here\n\"\"\"\nclustering = GirvanNewmanClustering(text, resolution=1.0, threshold=0.5)\nclusters = clustering.get_clusters()\nprint(clusters)\n</code></pre>"},{"location":"api_reference/chunk/gn_cluster/#functions","title":"Functions","text":""},{"location":"api_reference/chunk/gn_cluster/#encode_sentences","title":"<code>encode_sentences</code>","text":"<p>Encodes sentences into embeddings using BERT.</p>"},{"location":"api_reference/chunk/gn_cluster/#build_graph","title":"<code>build_graph</code>","text":"<p>Builds the graph using sentence embeddings and cosine similarity.</p>"},{"location":"api_reference/chunk/gn_cluster/#detect_communities","title":"<code>detect_communities</code>","text":"<p>Detects communities in the graph using the Girvan-Newman algorithm.</p>"},{"location":"api_reference/chunk/gn_cluster/#get_clusters","title":"<code>get_clusters</code>","text":"<p>Returns the clusters detected in the graph as a dictionary.</p>"},{"location":"api_reference/chunk/louvain_cluster/","title":"LouvainCluster","text":""},{"location":"api_reference/chunk/louvain_cluster/#overview","title":"Overview","text":"<p>The <code>LouvainCluster</code> class is designed to detect communities in a graph using the Louvain algorithm. It extends the <code>GraphClustering</code> class.</p>"},{"location":"api_reference/chunk/louvain_cluster/#arguments","title":"Arguments","text":"<ul> <li><code>text</code> (str): The input text containing sentences to be clustered.</li> <li><code>resolution</code> (float): The resolution parameter for the Louvain algorithm.</li> <li><code>threshold</code> (float): The similarity threshold for connecting nodes in the graph.</li> </ul>"},{"location":"api_reference/chunk/louvain_cluster/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>LouvainCluster</code> class:</p> <pre><code>from euler.clustering import LouvainCluster\n\ntext = \"\"\"\nYour text data here\n\"\"\"\nclustering = LouvainCluster(text, resolution=1.0, threshold=0.5)\nclusters = clustering.get_clusters()\nprint(clusters)\n</code></pre>"},{"location":"api_reference/chunk/louvain_cluster/#functions","title":"Functions","text":""},{"location":"api_reference/chunk/louvain_cluster/#encode_sentences","title":"<code>encode_sentences</code>","text":"<p>Encodes sentences into embeddings using BERT.</p>"},{"location":"api_reference/chunk/louvain_cluster/#build_graph","title":"<code>build_graph</code>","text":"<p>Builds the graph using sentence embeddings and cosine similarity.</p>"},{"location":"api_reference/chunk/louvain_cluster/#detect_communities","title":"<code>detect_communities</code>","text":"<p>Detects communities in the graph using the Louvain algorithm.</p>"},{"location":"api_reference/chunk/louvain_cluster/#get_clusters","title":"<code>get_clusters</code>","text":"<p>Returns the clusters detected in the graph as a dictionary.</p>"},{"location":"api_reference/chunk/lp_cluster/","title":"LabelPropagationClustering","text":""},{"location":"api_reference/chunk/lp_cluster/#overview","title":"Overview","text":"<p>The <code>LabelPropagationClustering</code> class is designed to detect communities in a graph using the Label Propagation algorithm. It extends the <code>GraphClustering</code> class.</p>"},{"location":"api_reference/chunk/lp_cluster/#arguments","title":"Arguments","text":"<ul> <li><code>text</code> (str): The input text containing sentences to be clustered.</li> <li><code>resolution</code> (float): The resolution parameter for the Label Propagation algorithm.</li> <li><code>threshold</code> (float): The similarity threshold for connecting nodes in the graph.</li> </ul>"},{"location":"api_reference/chunk/lp_cluster/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>LabelPropagationClustering</code> class:</p> <pre><code>from euler.clustering import LabelPropagationClustering\n\ntext = \"\"\"\nYour text data here\n\"\"\"\nclustering = LabelPropagationClustering(text, resolution=1.0, threshold=0.5)\nclusters = clustering.get_clusters()\nprint(clusters)\n</code></pre>"},{"location":"api_reference/chunk/lp_cluster/#functions","title":"Functions","text":""},{"location":"api_reference/chunk/lp_cluster/#encode_sentences","title":"<code>encode_sentences</code>","text":"<p>Encodes sentences into embeddings using BERT.</p>"},{"location":"api_reference/chunk/lp_cluster/#build_graph","title":"<code>build_graph</code>","text":"<p>Builds the graph using sentence embeddings and cosine similarity.</p>"},{"location":"api_reference/chunk/lp_cluster/#detect_communities","title":"<code>detect_communities</code>","text":"<p>Detects communities in the graph using the Label Propagation algorithm.</p>"},{"location":"api_reference/chunk/lp_cluster/#get_clusters","title":"<code>get_clusters</code>","text":"<p>Returns the clusters detected in the graph as a dictionary.</p>"},{"location":"api_reference/embeddings/node2vec/","title":"Node2Vec Graph Embeddings","text":""},{"location":"api_reference/embeddings/node2vec/#introduction","title":"Introduction","text":"<p>Node2Vec is a popular algorithm for generating vector representations of nodes in a graph. It aims to capture the network structure by performing biased random walks on the graph and then applying the Skip-Gram model from natural language processing to generate node embeddings. These embeddings can be used for various downstream tasks such as node classification, link prediction, and clustering.</p>"},{"location":"api_reference/embeddings/node2vec/#mathematical-definition","title":"Mathematical Definition","text":"<p>Given a graph ( G = (V, E) ), where ( V ) is the set of vertices and ( E ) is the set of edges, Node2Vec generates embeddings by optimizing the following objective function: <pre><code>\\[ \\max \\sum_{u \\in V} \\sum_{v \\in N_S(u)} \\log \\Pr(v | u) \\]\n</code></pre> where ( N_S(u) ) is a set of nodes sampled from random walks starting at node ( u ), and ( \\Pr(v | u) ) is the conditional probability of node ( v ) given node ( u ).</p>"},{"location":"api_reference/embeddings/node2vec/#conditional-probability","title":"Conditional Probability","text":"<p>The conditional probability ( \\Pr(v | u) ) is defined using the Softmax function: <pre><code>\\[ \\Pr(v | u) = \\frac{\\exp(\\mathbf{z}_v \\cdot \\mathbf{z}_u)}{\\sum_{v' \\in V} \\exp(\\mathbf{z}_{v'} \\cdot \\mathbf{z}_u)} \\]\n</code></pre> where ( \\mathbf{z}_u ) and ( \\mathbf{z}_v ) are the embedding vectors of nodes ( u ) and ( v ), respectively.</p>"},{"location":"api_reference/embeddings/node2vec/#random-walks","title":"Random Walks","text":"<p>Node2Vec generates random walks to capture the graph structure. These walks are controlled by two parameters:</p> <ul> <li>Return parameter ( p ): Controls the likelihood of returning to the previous node in the walk.</li> <li>In-out parameter ( q ): Controls the likelihood of exploring outward nodes.</li> </ul>"},{"location":"api_reference/embeddings/node2vec/#transition-probability","title":"Transition Probability","text":"<p>The transition probability from node ( t ) to node ( v ) given the previous node ( s ) is defined as: <pre><code>\\[ \\alpha_{pq}(t, v) = \n\\begin{cases} \n1/p &amp; \\text{if } d_{t,v} = 0 \\\\\n1 &amp; \\text{if } d_{t,v} = 1 \\\\\n1/q &amp; \\text{if } d_{t,v} = 2 \n\\end{cases}\n\\]\n</code></pre> where ( d_{t,v} ) is the shortest path distance between nodes ( t ) and ( v ).</p>"},{"location":"api_reference/embeddings/node2vec/#skip-gram-model","title":"Skip-Gram Model","text":"<p>The Skip-Gram model is used to optimize the embeddings by maximizing the probability of observing a node's neighbors in random walks. The objective function is: <pre><code>\\[ \\max \\sum_{u \\in V} \\sum_{v \\in N_S(u)} \\log \\Pr(v | u) \\]\n</code></pre></p>"},{"location":"api_reference/embeddings/node2vec/#example-code","title":"Example Code","text":"<p>Below is an example code that demonstrates how to generate Node2Vec embeddings using the <code>node2vec</code> Python package.</p> <pre><code>from euler.graph_api import KnowledgeGraphAPI\napi = KnowledgeGraphAPI()\n</code></pre>"},{"location":"api_reference/embeddings/node2vec/#create-more-nodes","title":"Create more nodes","text":"<pre><code>api.create_node(id='1', label='Person', properties={'name': 'Alice', 'age': 30})\napi.create_node(id='2', label='Person', properties={'name': 'Bob', 'age': 35})\napi.create_node(id='3', label='Person', properties={'name': 'Charlie', 'age': 25})\n</code></pre>"},{"location":"api_reference/embeddings/node2vec/#create-edges","title":"Create edges","text":"<pre><code>api.create_edge(id='1-2', source='1', target='2', label='knows', properties={'since': '2020'})\napi.create_edge(id='2-3', source='2', target='3', label='knows', properties={'since': '2018'})\napi.create_edge(id='3-1', source='3', target='4', label='knows', properties={'since': '2015'})\n</code></pre>"},{"location":"api_reference/embeddings/node2vec/#convert-graph-into-graph","title":"convert graph into Graph  <pre><code>network_graph = api.graph.to_networkx()\n</code></pre>","text":""},{"location":"api_reference/embeddings/node2vec/#create-node2vec-embeddings","title":"Create Node2Vec Embeddings <pre><code>api.graph.generate_embeddings(network_graph, method=\"node2vec\", dimensions=64, walk_length=30, num_walks=200, workers=4)\nnode2vec_embedding = api.graph.get_embedding('1')\nprint(\"Node2Vec embedding for node '1':\", node2vec_embedding)\n</code></pre>","text":""},{"location":"api_reference/embeddings/ollama/","title":"OllamaEmbedding","text":""},{"location":"api_reference/embeddings/ollama/#overview","title":"Overview","text":"<p>The <code>ollama_embed</code> function is designed to generate embeddings for a list of texts using the Ollama model. This functionality is part of the Euler Graph Database and can be accessed via the <code>EmbedFactory</code> class.</p>"},{"location":"api_reference/embeddings/ollama/#arguments","title":"Arguments","text":"<ul> <li><code>base_url</code> (str): The base URL for the Ollama API.</li> <li><code>model_name</code> (str): The name of the model to use for generating embeddings.</li> <li><code>texts</code> (List[str]): A list of texts to generate embeddings for.</li> <li><code>temperature</code> (float, optional): The temperature parameter for the model, defaults to 0.7.</li> </ul>"},{"location":"api_reference/embeddings/ollama/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>ollama_embed</code> function:</p> <pre><code>from euler.embed_factory import EmbedFactory\n</code></pre>"},{"location":"api_reference/embeddings/ollama/#initialize-the-ollama-embedding-reader","title":"Initialize the Ollama Embedding Reader","text":"<pre><code>openai_reader = EmbedFactory.get_llm_reader(\n    'ollama_embed',\n    base_url='http://localhost:11434',\n    model='nomic-embed-text:latest'\n)\n</code></pre>"},{"location":"api_reference/embeddings/ollama/#generate-embeddings-for-a-prompt","title":"Generate Embeddings for a Prompt","text":"<pre><code>result = openai_reader.generate_query_embeddings(\"Example prompt for the OpenAI model.\")\nprint(result if result else \"No response received.\")\n</code></pre>"},{"location":"api_reference/embeddings/ollama/#functions","title":"Functions","text":""},{"location":"api_reference/embeddings/ollama/#ollama_embed","title":"<code>ollama_embed</code>","text":"<p>The <code>ollama_embed</code> function takes a base URL, model name, a list of texts, and an optional temperature parameter to generate embeddings for each text in the list. It returns a list of embeddings.</p>"},{"location":"api_reference/embeddings/ollama/#process_embed","title":"<code>process_embed</code>","text":"<p>The <code>process_embed</code> function sends a request to the Ollama API with the provided base URL, model name, prompt, and temperature. It processes the response to extract and return the embedding for the given prompt.</p>"},{"location":"api_reference/embeddings/simple/","title":"Simple Graph Embeddings","text":""},{"location":"api_reference/embeddings/simple/#introduction","title":"Introduction","text":"<p>Graph embeddings are a way of representing graph nodes, edges, or entire graphs as vectors in a continuous vector space. This transformation allows the application of various machine learning algorithms directly on the graph data. The goal of graph embeddings is to capture the graph's structural and relational information in a lower-dimensional space.</p>"},{"location":"api_reference/embeddings/simple/#mathematical-definition","title":"Mathematical Definition","text":"<p>Given a graph ( G = (V, E) ), where ( V ) is the set of vertices and ( E ) is the set of edges, a graph embedding is a function ( f: V \\rightarrow \\mathbb{R}^d ) that maps each node to a ( d )-dimensional vector.</p>"},{"location":"api_reference/embeddings/simple/#objective","title":"Objective","text":"<p>The objective of graph embedding is to ensure that nodes that are close in the graph are also close in the embedding space. This can be mathematically formulated as minimizing the following objective function: <pre><code>\\[ \\min \\sum_{(u, v) \\in E} \\text{distance}(f(u), f(v)) \\]\n</code></pre> where ( \\text{distance} ) is typically the Euclidean distance between the vectors ( f(u) ) and ( f(v) ).</p>"},{"location":"api_reference/embeddings/simple/#simple-embeddings","title":"Simple Embeddings","text":"<p>A simple approach to generate graph embeddings is to use random embeddings or basic aggregation techniques. One such technique is to initialize each node's embedding randomly and then optimize it using gradient descent to minimize the objective function.</p>"},{"location":"api_reference/embeddings/simple/#random-initialization","title":"Random Initialization","text":"<pre><code>For a graph with \\( N \\) nodes, initialize a matrix \\( W \\in \\mathbb{R}^{N \\times d} \\) where each entry \\( W_{i,j} \\) is sampled from a normal distribution \\( \\mathcal{N}(0, \\sigma^2) \\).\n</code></pre>"},{"location":"api_reference/embeddings/simple/#optimization","title":"Optimization","text":"<p>The embeddings can be further refined using optimization techniques such as stochastic gradient descent (SGD) to minimize the objective function.</p>"},{"location":"api_reference/embeddings/simple/#example-code","title":"Example Code","text":"<p>Below is an example code that demonstrates how to generate simple graph embeddings using random initialization.</p> <pre><code>from euler.graph_api import KnowledgeGraphAPI\napi = KnowledgeGraphAPI()\n</code></pre>"},{"location":"api_reference/embeddings/simple/#create-more-nodes","title":"Create more nodes","text":"<pre><code>api.create_node(id='1', label='Person', properties={'name': 'Alice', 'age': 30})\napi.create_node(id='2', label='Person', properties={'name': 'Bob', 'age': 35})\napi.create_node(id='3', label='Person', properties={'name': 'Charlie', 'age': 25})\n</code></pre>"},{"location":"api_reference/embeddings/simple/#create-edges","title":"Create edges","text":"<pre><code>api.create_edge(id='1-2', source='1', target='2', label='knows', properties={'since': '2020'})\napi.create_edge(id='2-3', source='2', target='3', label='knows', properties={'since': '2018'})\napi.create_edge(id='3-1', source='3', target='4', label='knows', properties={'since': '2015'})\n</code></pre>"},{"location":"api_reference/embeddings/simple/#convert-graph-into-graph","title":"convert graph into Graph  <pre><code>network_graph = api.graph.to_networkx()\n</code></pre>","text":""},{"location":"api_reference/embeddings/simple/#generate-a-simple-embeddings","title":"Generate a simple embeddings <pre><code>api.graph.generate_embeddings(network_graph, method=\"simple\", dimensions=64)\nsimple_embedding = api.graph.get_embedding('1')\nprint(\"Simple embedding for node '1':\", simple_embedding)\n</code></pre>","text":""},{"location":"api_reference/evaluation/graph_evaluation/","title":"GraphEvaluation","text":""},{"location":"api_reference/evaluation/graph_evaluation/#overview","title":"Overview","text":"<p>The <code>GraphEval</code> class is designed to evaluate two graphs by calculating the intersection and computing evaluation metrics such as precision, recall, and F1 score. This class is part of the Euler Graph Database and extends the <code>GraphConfig</code> class.</p>"},{"location":"api_reference/evaluation/graph_evaluation/#arguments","title":"Arguments","text":"<ul> <li><code>retrival_graph</code> (Graph): Provide a union of sparse connected graph for the retrieval of the chunks.</li> <li><code>response_graph</code> (Graph): Provide a graph of generated response.</li> </ul>"},{"location":"api_reference/evaluation/graph_evaluation/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>GraphEval</code> class:</p> <pre><code>from euler.graph_evaluation import GraphEval, GraphEvaluationResponse\n</code></pre>"},{"location":"api_reference/evaluation/graph_evaluation/#initialize-the-knowledge-graphs","title":"Initialize the Knowledge Graphs","text":"<pre><code>context_retrival_graph = retrival_graph\nfinal_response_graph = response_graph\n</code></pre>"},{"location":"api_reference/evaluation/graph_evaluation/#convert-to-networkx-graphs-and-visualize","title":"Convert to NetworkX Graphs and Visualize","text":"<pre><code>context_retrival_graph_x = context_retrival_graph.graph.to_networkx()\nfinal_response_graph_x = final_response_graph.graph.to_networkx()\n\nfinal_response_graph.visualize_graph()\n</code></pre>"},{"location":"api_reference/evaluation/graph_evaluation/#evaluate-the-graphs","title":"Evaluate the Graphs","text":"<pre><code>result = GraphEval(context_retrival_graph_x, final_response_graph_x).get_evaluation()\n\nprint(f\"Precision: {result.eval_score[0]:.4f}\")\nprint(f\"Recall: {result.eval_score[1]:.4f}\")\nprint(f\"F1 Score: {result.eval_score[2]:.4f}\")\n</code></pre>"},{"location":"api_reference/evaluation/graph_evaluation/#example-output","title":"Example Output","text":"<pre><code>Precision: 0.7500\nRecall: 0.6000\nF1 Score: 0.6667\n</code></pre> <p>This documentation provides an overview, argument details, and a complete example of how to use the <code>GraphEval</code> class for evaluating graph intersections and computing precision, recall, and F1 score metrics.</p>"},{"location":"api_reference/llm/gemini/","title":"GeminiProReader","text":""},{"location":"api_reference/llm/gemini/#overview","title":"Overview","text":"<p>The <code>GeminiProReader</code> class is designed to interface with the Google Generative AI models (Gemini Pro) to extract relationships between entities in a given text. It extends the <code>BaseLLMReader</code> class and uses the <code>google-generativeai</code> library to communicate with the API.</p>"},{"location":"api_reference/llm/gemini/#installation","title":"Installation","text":"<ol> <li>Install the <code>google-generativeai</code> library:     <pre><code>pip install google-generativeai\n</code></pre></li> </ol>"},{"location":"api_reference/llm/gemini/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>GeminiProReader</code> class:</p> <pre><code>from euler.llm_readers import GeminiProReader\n\n# Initialize the GeminiProReader\ngemini_reader = GeminiProReader(api_key='your_google_api_key_here')\n\n# Read text and extract relationships\nresult = gemini_reader.read(\"Example text to analyze.\")\nprint(result.text if result else \"No response received.\")\n</code></pre>"},{"location":"api_reference/llm/gemini/#using-llmreaderfactory","title":"Using LLMReaderFactory","text":"<p>The <code>LLMReaderFactory</code> class can be used to easily initialize different LLM readers, including <code>GeminiProReader</code>.</p> <pre><code>from euler.llm_readers import LLMReaderFactory\n\n# Initialize the GeminiProReader using LLMReaderFactory\ngemini_reader = LLMReaderFactory.get_llm_reader(\n    reader_type='gemini_pro',\n    api_key='your_google_api_key_here'\n)\n\n# Read text and extract relationships\nresult = gemini_reader.read(\"Example text to analyze.\")\nprint(result.text if result else \"No response received.\")\n</code></pre>"},{"location":"api_reference/llm/gemini/#classes-and-methods","title":"Classes and Methods","text":""},{"location":"api_reference/llm/gemini/#geminiconfig","title":"<code>GeminiConfig</code>","text":"<p>The <code>GeminiConfig</code> class is a configuration model that holds the API key and an optional default prompt.</p> <p>Attributes: - <code>api_key</code> (str): The API key for accessing the Google Generative AI API. - <code>default_prompt</code> (Optional[str]): A default prompt to use if no custom prompt is provided.</p>"},{"location":"api_reference/llm/gemini/#geminiproresponse","title":"<code>GeminiProResponse</code>","text":"<p>The <code>GeminiProResponse</code> class represents the response from the Gemini Pro API.</p> <p>Attributes: - <code>text</code> (str): The response text generated by the Gemini Pro model.</p>"},{"location":"api_reference/llm/gemini/#geminiproreader_1","title":"<code>GeminiProReader</code>","text":"<p>The <code>GeminiProReader</code> class interfaces with the Google Generative AI models to extract relationships between entities in a given text.</p> <p>Methods: - <code>__init__(self, api_key: str, default_prompt: Optional[str] = None)</code>: Initializes the reader with the API key and optional default prompt. - <code>read(self, text: str, custom_prompt: Optional[str] = None) -&gt; Optional[GeminiProResponse]</code>: Reads the text and returns the extracted relationships.</p> <p>This documentation provides an overview, example usage, and detailed description of the <code>GeminiProReader</code> class and its associated classes and methods.</p>"},{"location":"api_reference/llm/huggingface/","title":"HuggingFaceReader","text":""},{"location":"api_reference/llm/huggingface/#overview","title":"Overview","text":"<p>The <code>HuggingFaceReader</code> class is designed to interface with Hugging Face's models to generate text based on a given prompt. It extends the <code>BaseLLMReader</code> class and uses the <code>transformers</code> library to communicate with the models.</p>"},{"location":"api_reference/llm/huggingface/#installation","title":"Installation","text":"<ol> <li>Install the <code>transformers</code> library:     <pre><code>pip install transformers\n</code></pre></li> </ol>"},{"location":"api_reference/llm/huggingface/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>HuggingFaceReader</code> class:</p> <pre><code>from euler.llm_readers import HuggingFaceReader\n\n# Initialize the HuggingFaceReader\nhuggingface_reader = HuggingFaceReader(\n    api_key='your_hugging_face_api_key_here',\n    model_id='gpt2'\n)\n\n# Generate text based on the input prompt\ntext = \"Once upon a time in a faraway land,\"\nresponse = huggingface_reader.read(text)\nprint(response.text if response else \"No response received.\")\n</code></pre>"},{"location":"api_reference/llm/huggingface/#using-llmreaderfactory","title":"Using LLMReaderFactory","text":"<p>The <code>LLMReaderFactory</code> class can be used to easily initialize different LLM readers, including <code>HuggingFaceReader</code>.</p> <pre><code>from euler.llm_readers import LLMReaderFactory\n\n# Initialize the HuggingFaceReader using LLMReaderFactory\nhuggingface_reader = LLMReaderFactory.get_llm_reader(\n    reader_type='huggingface',\n    api_key='your_hugging_face_api_key_here',\n    model_id='gpt2'\n)\n\n# Generate text based on the input prompt\ntext = \"Once upon a time in a faraway land,\"\nresponse = huggingface_reader.read(text)\nprint(response.text if response else \"No response received.\")\n</code></pre>"},{"location":"api_reference/llm/huggingface/#classes-and-methods","title":"Classes and Methods","text":""},{"location":"api_reference/llm/huggingface/#huggingfaceconfig","title":"<code>HuggingFaceConfig</code>","text":"<p>The <code>HuggingFaceConfig</code> class is a configuration model that holds the API key, model ID, and an optional default prompt.</p> <p>Attributes: - <code>api_key</code> (str): The API key for accessing the Hugging Face API. - <code>model_id</code> (str): The model ID to use for generating responses. - <code>default_prompt</code> (Optional[str]): A default prompt to use if no custom prompt is provided.</p>"},{"location":"api_reference/llm/huggingface/#huggingfaceresponse","title":"<code>HuggingFaceResponse</code>","text":"<p>The <code>HuggingFaceResponse</code> class represents the response from the Hugging Face API.</p> <p>Attributes: - <code>text</code> (str): The response text generated by the Hugging Face model.</p>"},{"location":"api_reference/llm/huggingface/#huggingfacereader_1","title":"<code>HuggingFaceReader</code>","text":"<p>The <code>HuggingFaceReader</code> class interfaces with Hugging Face's models to generate text based on a given prompt.</p> <p>Methods: - <code>__init__(self, api_key: str, model_id: str = 'gpt2', default_prompt: Optional[str] = None)</code>: Initializes the reader with the API key, model ID, and optional default prompt. - <code>read(self, text: str, custom_prompt: Optional[str] = None) -&gt; Optional[HuggingFaceResponse]</code>: Reads the text and returns the generated response.</p> <p>This documentation provides an overview, example usage, and detailed description of the <code>HuggingFaceReader</code> class and its associated classes and methods.</p>"},{"location":"api_reference/llm/ollama/","title":"OllamaReader","text":""},{"location":"api_reference/llm/ollama/#overview","title":"Overview","text":"<p>The <code>OllamaReader</code> class is designed to interface with hosted Ollama models to extract relationships between entities in a given text. It extends the <code>BaseLLMReader</code> class and uses the <code>requests</code> library to communicate with the API.</p>"},{"location":"api_reference/llm/ollama/#installation","title":"Installation","text":"<ol> <li>Install the <code>requests</code> library:     <pre><code>pip install requests\n</code></pre></li> </ol>"},{"location":"api_reference/llm/ollama/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>OllamaReader</code> class:</p> <pre><code>from euler.llm_readers import OllamaReader\n\n# Initialize the OllamaReader\nollama_reader = OllamaReader(\n    base_url=\"http://localhost:11434\", \n    model=\"qwen2:0.5b\",           \n    temprature=0.7\n)\n\n# Read text and extract relationships\ntext = \"\"\"Thomas Alva Edison was an American inventor and businessman. He developed many devices in fields such as electric power generation, mass communication, sound recording, and motion pictures.\"\"\"\nresponse = ollama_reader.read(text)\nprint(response.text if response else \"No response received.\")\n</code></pre>"},{"location":"api_reference/llm/ollama/#using-llmreaderfactory","title":"Using LLMReaderFactory","text":"<p>The <code>LLMReaderFactory</code> class can be used to easily initialize different LLM readers, including <code>OllamaReader</code>.</p> <pre><code>from euler.llm_readers import LLMReaderFactory\n\n# Initialize the OllamaReader using LLMReaderFactory\nollama_reader = LLMReaderFactory.get_llm_reader(\n    reader_type='ollama',\n    base_url=\"http://localhost:11434\", \n    model=\"qwen2:0.5b\",           \n    temprature=0.7\n)\n\n# Read text and extract relationships\ntext = \"\"\"Thomas Alva Edison was an American inventor and businessman. He developed many devices in fields such as electric power generation, mass communication, sound recording, and motion pictures.\"\"\"\nresponse = ollama_reader.read(text)\nprint(response.text if response else \"No response received.\")\n</code></pre>"},{"location":"api_reference/llm/ollama/#classes-and-methods","title":"Classes and Methods","text":""},{"location":"api_reference/llm/ollama/#ollamaconfig","title":"<code>OllamaConfig</code>","text":"<p>The <code>OllamaConfig</code> class is a configuration model that holds the API base URL, model name, temperature, context window, and an optional default prompt.</p> <p>Attributes: - <code>base_url</code> (str): The base URL for the hosted model. - <code>model</code> (str): The hosted Ollama model to use. - <code>temprature</code> (float): The sample temperature. - <code>context_window</code> (int): The maximum number of tokens in the context. - <code>default_prompt</code> (Optional[str]): A default prompt to use if no custom prompt is provided.</p>"},{"location":"api_reference/llm/ollama/#ollamaresponse","title":"<code>OllamaResponse</code>","text":"<p>The <code>OllamaResponse</code> class represents the response from the Ollama API.</p> <p>Attributes: - <code>text</code> (str): The response text generated by the Ollama model.</p>"},{"location":"api_reference/llm/ollama/#ollamareader_1","title":"<code>OllamaReader</code>","text":"<p>The <code>OllamaReader</code> class interfaces with the hosted Ollama models to extract relationships between entities in a given text.</p> <p>Methods: - <code>__init__(self, base_url: str, model: str, temprature: float = 0.75, default_prompt: Optional[str] = None)</code>: Initializes the reader with the base URL, model, temperature, and optional default prompt. - <code>read(self, text: str, custom_prompt: Optional[str] = None) -&gt; Optional[OllamaResponse]</code>: Reads the text and returns the extracted relationships. - <code>stream_complete(self, prompt: str, **kwargs: Any) -&gt; Optional[OllamaResponse]</code>: Sends a request to the Ollama API and processes the streamed response.</p> <p>This documentation provides an overview, example usage, and detailed description of the <code>OllamaReader</code> class and its associated classes and methods.</p>"},{"location":"api_reference/llm/openai/","title":"OpenAIReader","text":""},{"location":"api_reference/llm/openai/#overview","title":"Overview","text":"<p>The <code>OpenAIReader</code> class is designed to interface with OpenAI's GPT-3 models to extract relationships between entities in a given text. It extends the <code>BaseLLMReader</code> class and uses the <code>openai</code> library to communicate with the API.</p>"},{"location":"api_reference/llm/openai/#installation","title":"Installation","text":"<ol> <li>Install the <code>openai</code> library:     <pre><code>pip install openai\n</code></pre></li> </ol>"},{"location":"api_reference/llm/openai/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>OpenAIReader</code> class:</p> <pre><code>from euler.llm_readers import OpenAIReader\n\n# Initialize the OpenAIReader\nopenai_reader = OpenAIReader(\n    api_key='your_openai_api_key_here',\n    model_id='text-davinci-003'\n)\n\n# Read text and extract relationships\ntext = \"\"\"Thomas Alva Edison was an American inventor and businessman. He developed many devices in fields such as electric power generation, mass communication, sound recording, and motion pictures.\"\"\"\nresponse = openai_reader.read(text)\nprint(response.text if response else \"No response received.\")\n</code></pre>"},{"location":"api_reference/llm/openai/#using-llmreaderfactory","title":"Using LLMReaderFactory","text":"<p>The <code>LLMReaderFactory</code> class can be used to easily initialize different LLM readers, including <code>OpenAIReader</code>.</p> <pre><code>from euler.llm_readers import LLMReaderFactory\n\n# Initialize the OpenAIReader using LLMReaderFactory\nopenai_reader = LLMReaderFactory.get_llm_reader(\n    reader_type='openai',\n    api_key='your_openai_api_key_here',\n    model_id='text-davinci-003'\n)\n\n# Read text and extract relationships\ntext = \"\"\"Thomas Alva Edison was an American inventor and businessman. He developed many devices in fields such as electric power generation, mass communication, sound recording, and motion pictures.\"\"\"\nresponse = openai_reader.read(text)\nprint(response.text if response else \"No response received.\")\n</code></pre>"},{"location":"api_reference/llm/openai/#classes-and-methods","title":"Classes and Methods","text":""},{"location":"api_reference/llm/openai/#openaiconfig","title":"<code>OpenAIConfig</code>","text":"<p>The <code>OpenAIConfig</code> class is a configuration model that holds the API key and model ID.</p> <p>Attributes: - <code>api_key</code> (str): The API key for accessing the OpenAI API. - <code>model_id</code> (str): The model ID to use for generating responses.</p>"},{"location":"api_reference/llm/openai/#openairesponse","title":"<code>OpenAIResponse</code>","text":"<p>The <code>OpenAIResponse</code> class represents the response from the OpenAI API.</p> <p>Attributes: - <code>text</code> (str): The response text generated by the OpenAI model.</p>"},{"location":"api_reference/llm/openai/#openaireader_1","title":"<code>OpenAIReader</code>","text":"<p>The <code>OpenAIReader</code> class interfaces with OpenAI's GPT-3 models to extract relationships between entities in a given text.</p> <p>Methods: - <code>__init__(self, api_key: str, model_id: str = 'text-davinci-003')</code>: Initializes the reader with the API key and model ID. - <code>read(self, text: str, custom_prompt: Optional[str] = None) -&gt; Optional[OpenAIResponse]</code>: Reads the text and returns the extracted relationships.</p> <p>This documentation provides an overview, example usage, and detailed description of the <code>OpenAIReader</code> class and its associated classes and methods.</p>"},{"location":"api_reference/path_finding/dijkstra/","title":"PathFinding","text":""},{"location":"api_reference/path_finding/dijkstra/#overview","title":"Overview","text":"<p>The <code>DijkstraPathFinder</code> class is designed to find the shortest path between two nodes in a graph using Dijkstra's algorithm. This functionality is part of the Euler Graph Database and extends the <code>BasePathFinder</code> class.</p>"},{"location":"api_reference/path_finding/dijkstra/#arguments","title":"Arguments","text":"<ul> <li><code>graph</code> (nx.Graph): The graph in which to find the path.</li> <li><code>start_node</code> (str): The starting node for the path.</li> <li><code>end_node</code> (str): The ending node for the path.</li> </ul>"},{"location":"api_reference/path_finding/dijkstra/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>DijkstraPathFinder</code> class:</p> <pre><code>from euler.path_finding.dijkstra_pathfinder import DijkstraPathFinder\n</code></pre>"},{"location":"api_reference/path_finding/dijkstra/#initialize-the-knowledge-graph","title":"Initialize the Knowledge Graph","text":"<pre><code>graph = euler_graph.graph.to_networkx()\n</code></pre>"},{"location":"api_reference/path_finding/dijkstra/#find-the-path-using-dijkstras-algorithm","title":"Find the Path Using Dijkstra's Algorithm","text":"<pre><code>path_finder = DijkstraPathFinder(graph, start_node='1', end_node='4')\nprint(f\"Path: {path_finder.find_path().path}\")\n</code></pre>"},{"location":"api_reference/path_finding/dijkstra/#functions","title":"Functions","text":""},{"location":"api_reference/path_finding/dijkstra/#pathfinderconfig","title":"<code>PathFinderConfig</code>","text":"<p>The <code>PathFinderConfig</code> class is a configuration model that defines the structure of the graph, start node, and end node.</p>"},{"location":"api_reference/path_finding/dijkstra/#pathresponse","title":"<code>PathResponse</code>","text":"<p>The <code>PathResponse</code> class is a model that defines the structure of the response, including the path found.</p>"},{"location":"api_reference/path_finding/dijkstra/#dijkstrapathfinder","title":"<code>DijkstraPathFinder</code>","text":"<p>The <code>DijkstraPathFinder</code> class uses Dijkstra's algorithm to find the shortest path between the start node and the end node in the given graph. It returns a <code>PathResponse</code> object containing the path.</p> <p>This documentation provides an overview, argument details, and a complete example of how to use the <code>DijkstraPathFinder</code> class for finding the shortest path in a graph using Dijkstra's algorithm.</p>"},{"location":"api_reference/prompt/prompt/","title":"EulerPromptTemplate","text":""},{"location":"api_reference/prompt/prompt/#overview","title":"Overview","text":"<p>The <code>EulerPromptTemplate</code> class is designed to create customizable prompt templates for language models. It allows users to generate prompts using either f-strings or jinja2 syntax, with a strong recommendation to use f-strings for security reasons.</p>"},{"location":"api_reference/prompt/prompt/#arguments","title":"Arguments","text":"<ul> <li><code>input_variables</code> (List[str]): A list of the names of the variables the prompt template expects.</li> <li><code>template</code> (str): The prompt template.</li> <li><code>template_format</code> (Literal[\"f-string\", \"jinja2\"]): The format of the prompt template. Options are: 'f-string', 'jinja2'.</li> <li><code>validate_template</code> (bool): Whether or not to try validating the template.</li> </ul>"},{"location":"api_reference/prompt/prompt/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>EulerPromptTemplate</code> class:</p> <pre><code>from euler.prompts.prompt import EulerPromptTemplate\n\n# Instantiation using from_template (recommended)\nprompt = EulerPromptTemplate.from_template(\"Say {foo}\")\nformatted_prompt = prompt.format(foo=\"bar\")\nprint(formatted_prompt)  # Output: Say bar\n</code></pre>"},{"location":"api_reference/prompt/prompt/#custom-prompt-example","title":"Custom Prompt Example","text":"<p>You can create a custom prompt by subclassing <code>EulerPromptTemplate</code>:</p> <pre><code>from euler.prompts.prompt import EulerPromptTemplate\n\nclass CustomPrompt(EulerPromptTemplate):\n    def __init__(self):\n        super().__init__(\n            input_variables=[\"context\", \"query\"],\n            template=\"Give me a detailed description and use your knowledge base to return an answer in 100 words with subheading and conclusion and also add some references. If you don't know the answer, please contact the Author of LIB: Prashant Verma.\\nContext: {context}\\nQuery: {query}\",\n            template_format=\"f-string\"\n        )\n\nclass ConversationalAgent:\n    def __init__(self, graph):\n        self.graph = graph\n        self.context = []\n        self.custom_prompt = CustomPrompt()\n\n    def handle_query(self, query):\n        self.context.append(query)\n        formatted_prompt = self.custom_prompt.format(context=\" \".join(self.context), query=query)\n        response = text_data_processing.generate_response(formatted_prompt, self.graph)\n        self.context.append(response)\n        return response\n</code></pre>"},{"location":"api_reference/prompt/prompt/#functions","title":"Functions","text":""},{"location":"api_reference/prompt/prompt/#format","title":"<code>format</code>","text":"<p>Formats the prompt with the inputs.</p> <p>Arguments: - <code>kwargs</code>: Any arguments to be passed to the prompt template.</p> <p>Returns: - A formatted string.</p> <p>Example:</p> <pre><code>prompt = EulerPromptTemplate.from_template(\"Hello, {name}!\")\nformatted_prompt = prompt.format(name=\"Alice\")\nprint(formatted_prompt)  # Output: Hello, Alice!\n</code></pre>"},{"location":"api_reference/prompt/prompt/#from_template","title":"<code>from_template</code>","text":"<p>Loads a prompt template from a template string.</p> <p>Arguments: - <code>template</code> (str): The template to load. - <code>template_format</code> (str, optional): The format of the template. Use <code>jinja2</code> for jinja2, and <code>f-string</code> or None for f-strings. - <code>partial_variables</code> (Dict[str, Any], optional): A dictionary of variables that can be used to partially fill in the template.</p> <p>Returns: - The prompt template loaded from the template.</p> <p>Example:</p> <pre><code>prompt = EulerPromptTemplate.from_template(\"Hi {name}, welcome to {place}!\")\nformatted_prompt = prompt.format(name=\"Alice\", place=\"Wonderland\")\nprint(formatted_prompt)  # Output: Hi Alice, welcome to Wonderland!\n</code></pre>"},{"location":"api_reference/prompt/prompt/#from_file","title":"<code>from_file</code>","text":"<p>Loads a prompt from a file.</p> <p>Arguments: - <code>template_file</code> (Union[str, Path]): The path to the file containing the prompt template.</p> <p>Returns: - The prompt loaded from the file.</p> <p>Example:</p> <pre><code>prompt = EulerPromptTemplate.from_file(\"path/to/template.txt\")\nformatted_prompt = prompt.format(name=\"Alice\")\nprint(formatted_prompt)\n</code></pre>"},{"location":"api_reference/prompt/prompt/#from_examples","title":"<code>from_examples</code>","text":"<p>Creates a prompt template from a list of examples.</p> <p>Arguments: - <code>examples</code> (List[str]): List of examples to use in the prompt. - <code>suffix</code> (str): String to go after the list of examples. Should generally set up the user's input. - <code>input_variables</code> (List[str]): A list of variable names the final prompt template will expect. - <code>example_separator</code> (str, optional): The separator to use in between examples. Defaults to two new line characters. - <code>prefix</code> (str, optional): String that should go before any examples. Generally includes examples. Default to an empty string.</p> <p>Returns: - The final prompt generated.</p> <p>Example:</p> <pre><code>examples = [\"Example 1: {example1}\", \"Example 2: {example2}\"]\nprompt = EulerPromptTemplate.from_examples(\n    examples=examples,\n    suffix=\"Now, please provide your input.\",\n    input_variables=[\"example1\", \"example2\"]\n)\nformatted_prompt = prompt.format(example1=\"First example\", example2=\"Second example\")\nprint(formatted_prompt)\n</code></pre> <p>This documentation provides an overview, usage examples, and function descriptions for the <code>EulerPromptTemplate</code> class, which is designed to create customizable prompt templates for language models.</p>"},{"location":"api_reference/readers/dataframe/","title":"ReadDataFrame","text":""},{"location":"api_reference/readers/dataframe/#overview","title":"Overview","text":"<p>The <code>ReadDataFrame</code> class is designed to read a pandas DataFrame and convert each row into a <code>Document</code> object. This functionality is part of the Euler Graph Database and extends the <code>BaseReader</code> class.</p>"},{"location":"api_reference/readers/dataframe/#arguments","title":"Arguments","text":"<ul> <li><code>dataframe</code> (pd.DataFrame): The pandas DataFrame to read from.</li> <li><code>source_column</code> (Optional[str]): The column in the DataFrame to use as the source metadata for each document.</li> </ul>"},{"location":"api_reference/readers/dataframe/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>ReadDataFrame</code> class:</p> <pre><code>import pandas as pd\nfrom euler.reader.read_dataframe import ReadDataFrame\n</code></pre>"},{"location":"api_reference/readers/dataframe/#initialize-the-dataframe","title":"Initialize the DataFrame","text":"<pre><code># Example set of data\ndata = {\n    'Name': ['Prashant', 'John'],\n    'Age': [28, 34],\n    'Source': ['Employee Records', 'HR Database']\n}\ndf = pd.DataFrame(data)\n</code></pre>"},{"location":"api_reference/readers/dataframe/#create-the-readdataframe-instance","title":"Create the ReadDataFrame Instance","text":"<pre><code>reader = ReadDataFrame(dataframe=df, source_column=\"Source\")\n</code></pre>"},{"location":"api_reference/readers/dataframe/#load-the-documents","title":"Load the Documents","text":"<pre><code>documents = reader.load()\nfor doc in documents:\n    print(doc.page_content)\n    print(doc.metadata)\n</code></pre>"},{"location":"api_reference/readers/dataframe/#functions","title":"Functions","text":""},{"location":"api_reference/readers/dataframe/#check_dataframe","title":"<code>check_dataframe</code>","text":"<p>The <code>check_dataframe</code> method validates that the <code>dataframe</code> attribute is a pandas DataFrame. It raises a <code>TypeError</code> if the value is not a DataFrame.</p>"},{"location":"api_reference/readers/dataframe/#load","title":"<code>load</code>","text":"<p>The <code>load</code> method reads the DataFrame and converts each row into a <code>Document</code> object. It returns a list of <code>Document</code> objects. If the DataFrame is empty, it raises a <code>ValueError</code>.</p> <p>This documentation provides an overview, argument details, and a complete example of how to use the <code>ReadDataFrame</code> class for converting DataFrame rows into <code>Document</code> objects.</p>"},{"location":"api_reference/readers/pdf/","title":"PDFReader","text":""},{"location":"api_reference/readers/pdf/#overview","title":"Overview","text":"<p>The <code>PDFReader</code> class is designed to read PDF files and convert each page into a <code>Document</code> object. This class is part of the Euler Graph Database and extends the <code>BaseReader</code> class.</p>"},{"location":"api_reference/readers/pdf/#arguments","title":"Arguments","text":"<ul> <li><code>file</code> (Path): Path to the PDF file to load.</li> <li><code>extra_info</code> (Optional[Dict]): Additional metadata to include with each document.</li> </ul>"},{"location":"api_reference/readers/pdf/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>PDFReader</code> class:</p> <pre><code>from pathlib import Path\nfrom euler.reader.pdf_reader import PDFReader\n</code></pre>"},{"location":"api_reference/readers/pdf/#initialize-the-pdfreader","title":"Initialize the PDFReader","text":"<pre><code>reader = PDFReader()\n</code></pre>"},{"location":"api_reference/readers/pdf/#load-the-documents-from-the-pdf-file-with-additional-metadata","title":"Load the documents from the PDF file with additional metadata","text":"<pre><code>documents = reader.load(Path(\"example.pdf\"), extra_info={\"author\": \"John Doe\"})\n</code></pre>"},{"location":"api_reference/readers/pdf/#print-the-loaded-documents","title":"#Print the loaded documents","text":"<pre><code>for doc in documents:\n    print(doc.text)\n    print(doc.metadata)\n</code></pre>"},{"location":"api_reference/readers/text/","title":"TextReader","text":""},{"location":"api_reference/readers/text/#overview","title":"Overview","text":"<p>The <code>TextReader</code> class is designed to read text files with specified encoding. It can optionally autodetect file encoding if the specified encoding fails. This class is part of the Euler Graph Database and extends the <code>BaseReader</code> class.</p>"},{"location":"api_reference/readers/text/#arguments","title":"Arguments","text":"<ul> <li><code>file_path</code> (str): Path to the file to load.</li> <li><code>encoding</code> (Optional[str]): File encoding to use. If <code>None</code>, the file will be loaded with the default system encoding.</li> <li><code>autodetect_encoding</code> (bool): Whether to try to autodetect the file encoding if the specified encoding fails. Default is <code>False</code>.</li> </ul>"},{"location":"api_reference/readers/text/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>TextReader</code> class:</p> <pre><code>from euler.reader.text_reader import TextReader\n</code></pre>"},{"location":"api_reference/readers/text/#initialize-the-textreader-with-file-path-encoding-and-autodetect_encoding","title":"Initialize the TextReader with file path, encoding, and autodetect_encoding","text":"<pre><code>reader = TextReader(file_path=\"example.txt\", encoding=\"utf-8\", autodetect_encoding=True)\n</code></pre>"},{"location":"api_reference/readers/text/#load-the-document","title":"Load the document","text":"<pre><code>documents = reader.load()\n</code></pre>"},{"location":"api_reference/readers/text/#print-the-loaded-documents","title":"Print the loaded documents","text":"<pre><code>for doc in documents:\n    print(doc.text)\n    print(doc.metadata)\n</code></pre>"},{"location":"api_reference/readers/xlsx/","title":"ReadXlsx","text":""},{"location":"api_reference/readers/xlsx/#overview","title":"Overview","text":"<p>The <code>ReadXlsx</code> class is designed to read Excel files (<code>.xlsx</code>) and convert each row into a <code>Document</code> object. This class is part of the Euler Graph Database and extends the <code>BaseReader</code> class.</p>"},{"location":"api_reference/readers/xlsx/#arguments","title":"Arguments","text":"<ul> <li><code>file_path</code> (str): Path to the Excel file to load.</li> <li><code>source_column</code> (Optional[str]): The column name to use as the source identifier in the metadata. If <code>None</code>, the file path will be used as the source.</li> <li><code>sheet_name</code> (Optional[str]): The name of the sheet to load. If <code>None</code>, the first sheet will be used.</li> <li><code>encoding</code> (Optional[str]): The encoding to use for reading the file. This parameter is not typically needed for Excel files.</li> </ul>"},{"location":"api_reference/readers/xlsx/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>ReadXlsx</code> class:</p> <pre><code>from euler.reader.xlsx_reader import ReadXlsx\n</code></pre>"},{"location":"api_reference/readers/xlsx/#initialize-the-readxlsx-with-file-path-source-column-and-sheet-name","title":"Initialize the ReadXlsx with file path, source column, and sheet name","text":"<pre><code>reader = ReadXlsx(file_path=\"example.xlsx\", source_column=\"Source\", sheet_name=\"Sheet1\")\n</code></pre>"},{"location":"api_reference/readers/xlsx/#load-the-documents","title":"Load the documents","text":"<pre><code>documents = reader.load()\n</code></pre>"},{"location":"api_reference/readers/xlsx/#print-the-loaded-documents","title":"Print the loaded documents","text":"<pre><code>for doc in documents:\n    print(doc.text)\n    print(doc.metadata)\n</code></pre>"},{"location":"api_reference/vector_store/chroma/","title":"Chroma Vector DB","text":""},{"location":"api_reference/vector_store/faiss/","title":"Faiss Vector DB","text":""},{"location":"api_reference/vector_store/faiss/#overview","title":"Overview","text":"<p>The <code>FaissVectorDB</code> class is designed to manage and query vector embeddings using the FAISS library. This functionality is part of the Euler Graph Database and extends the <code>BaseVectorStore</code> class.</p>"},{"location":"api_reference/vector_store/faiss/#arguments","title":"Arguments","text":"<ul> <li><code>dimension</code> (int): The dimensionality of the vectors to be indexed.</li> <li><code>index</code> (faiss.IndexIDMap): The FAISS index for storing and querying vectors, initialized in the <code>__post_init__</code> method.</li> </ul>"},{"location":"api_reference/vector_store/faiss/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>FaissVectorDB</code> class:</p> <pre><code>from euler.vector_store.faiss_vector_db import FaissVectorDB\nfrom euler.graph_api import KnowledgeGraphAPI\n</code></pre>"},{"location":"api_reference/vector_store/faiss/#initialize-the-faiss-vector-database","title":"Initialize the FAISS Vector Database","text":"<pre><code>vector_db = FaissVectorDB(dimension=64)\n</code></pre>"},{"location":"api_reference/vector_store/faiss/#generate-and-add-embeddings","title":"Generate and Add Embeddings","text":"<pre><code>api = KnowledgeGraphAPI()\napi.graph.generate_embeddings(network_graph, method=\"simple\", dimensions=64)\nsimple_embedding = api.graph.get_embedding('1')\nprint(\"Simple embedding for node '1':\", simple_embedding)\n\nembeddings = {node_id: api.graph.get_embedding(node_id) for node_id in api.graph.nodes}\nvector_db.add_vectors(list(embeddings.values()), list(map(int, embeddings.keys())))\n</code></pre>"},{"location":"api_reference/vector_store/faiss/#generate-node2vec-embeddings","title":"Generate Node2Vec Embeddings","text":"<pre><code>api.graph.generate_embeddings(network_graph, method=\"node2vec\", dimensions=64, walk_length=30, num_walks=200, workers=4)\nnode2vec_embedding = api.graph.get_embedding('1')\nprint(\"Node2Vec embedding for node '1':\", node2vec_embedding)\n</code></pre>"},{"location":"api_reference/vector_store/faiss/#save-and-load-the-index","title":"Save and Load the Index","text":"<pre><code># Save\napi.save_graph(\"graph.json\")\nvector_db.save(\"faiss_index.bin\")\n\n# Load\napi.load_graph(\"graph.json\")\nvector_db.load(\"faiss_index.bin\")\n</code></pre>"},{"location":"api_reference/vector_store/faiss/#query-the-faiss-index","title":"Query the FAISS Index","text":"<pre><code># FAISS index for nearest neighbors of node '1'\nquery_results = vector_db.query_vectors(api.graph.get_embedding('1'), k=4)\nprint(\"Query results after loading:\", query_results)\n\napi.visualize_graph(file_path='graph.png')\n</code></pre>"},{"location":"api_reference/vector_store/faiss/#functions","title":"Functions","text":""},{"location":"api_reference/vector_store/faiss/#__post_init__","title":"<code>__post_init__</code>","text":"<p>The <code>__post_init__</code> method initializes the FAISS index using <code>IndexFlatL2</code> and wraps it in <code>IndexIDMap</code>.</p>"},{"location":"api_reference/vector_store/faiss/#add_vectors","title":"<code>add_vectors</code>","text":"<p>The <code>add_vectors</code> method adds vectors to the FAISS index. It takes a list of vectors and a corresponding list of IDs. The vectors are converted to a NumPy array before being added to the index.</p>"},{"location":"api_reference/vector_store/faiss/#query_vectors","title":"<code>query_vectors</code>","text":"<p>The <code>query_vectors</code> method queries the FAISS index for the k nearest neighbors of a given vector. It returns a list of IDs of the k nearest neighbors.</p>"},{"location":"api_reference/vector_store/faiss/#save","title":"<code>save</code>","text":"<p>The <code>save</code> method saves the FAISS index to a file. It takes the path to the file as an argument.</p>"},{"location":"api_reference/vector_store/faiss/#load","title":"<code>load</code>","text":"<p>The <code>load</code> method loads the FAISS index from a file. It takes the path to the file as an argument.</p> <p>This documentation provides an overview, argument details, and a complete example of how to use the <code>FaissVectorDB</code> class for managing and querying vector embeddings using the FAISS library.</p>"},{"location":"api_reference/vector_store/milvus/","title":"Milvus Vector DB","text":""},{"location":"api_reference/vector_store/pinecone/","title":"Pinecone Vector DB","text":""}]}